# 2025/02/11

## [SE-0453: InlineArray, a fixed-size array](https://github.com/swift-evolution/blob/main/proposals/0453-vector.md)

### ステータス
Active review

### 背景
Swiftでの配列はヒープに格納され、サイズが動的に変更可能なため、パフォーマンス上の問題を引き起こすことがあります。特に、固定サイズのデータ構造が必要な場合に、現在の`Array`型では過剰なメモリ使用や不要な操作が生じることがあります。このような状況を改善するため、安全で効率的なスタック上の固定サイズ配列のサポートが求められています。

### 提案内容
`InlineArray`という新しい型を導入し、固定サイズの配列を提供します。この型は、スタック上に割り当てられ、クラスプロパティのメンバーとして使用された場合には、他のプロパティとともにヒープ上にインラインで割り当てられます。これにより、不要なヒープ割り当てを避けつつ、安全な配列操作を可能にします。さらに、リテラル初期化やクロージャベースの初期化を通じて、使いやすさと柔軟性を提供します。

### 採択されると何が嬉しいのか
`InlineArray`が導入されることで、Swift開発者は安全に固定サイズ配列を使用でき、メモリ管理やパフォーマンスの改善が期待できます。特にリソースが限られた組み込みシステムや性能が重視されるアプリケーションで大きな恩恵があります。また、従来は非安全な方法を使わざるを得なかった場面で、安全に操作を行うことが可能になります。

### 周辺知識
`InlineArray`を理解するには、現在のSwiftの`Array`型の特性、特にそのヒープ割り当てと自動サイズ変更の動作を理解することが重要です。また、SE-0322で提案された`withUnsafeTemporaryAllocation`など、既存のメモリ管理技術についても理解が求められます。その他、C++の`std::array`やRustの配列など、他言語の固定サイズ配列との比較も有用です。

## [SE-0460: Explicit Specialization](0460-specialized.md)

### ステータス
Active review

### 背景
Swiftコンパイラは、コンパイル時に汎用関数を「特殊化」する能力を持っています。これは、汎用関数のプレースホルダーを具体的な型に置き換えることで、最適化されたカスタム実装を生成します。しかし、場合によってはこの特殊化がコンパイラから隠され、最適化されたバージョンの関数が利用できません。このプロポーザルは、新しい属性`@specialized`を導入し、特定の型用に事前に特殊化された関数を生成できるようにします。

### 提案内容
`@specialized`属性を使用して、開発者が特定の型に対するプリスペシャライズされたバージョンの関数を生成できるようにします。未特殊化の関数が特定の型で呼び出された場合、事前に特殊化されたバージョンにリダイレクトされるコードが生成されます。これにより、例えば`[Int]`型での`sum()`関数の実行時に最適化されたパフォーマンスが得られるようになります。

### 採択されると何が嬉しいのか
このプロポーザルが承認されると、Swift開発者はカスタム特殊化によるパフォーマンスの向上を利用できるようになります。特に、型消去やバイナリフレームワークでの実装の隠蔽が必要な場合に、有効な最適化手法が提供されます。

### 周辺知識
このプロポーザルを理解するためには、Swiftにおけるジェネリクスやプロトコル拡張、型消去に関する知識が必要です。また、`@inlinable`属性や Swift ABI に関連する知識も役立ちます。類似のプロポーザルや既存の最適化技術との比較も理解を深める助けになります。

